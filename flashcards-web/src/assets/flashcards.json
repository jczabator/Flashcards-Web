{
  "data": [
    {
		"id": 1,
		"flashcardSetId": 1,
		"name": "Why not use GET to send data to the API?",
		"text": "2000 characters limitation. When you send data in query string even on https it is visible. Body of request is not visible with https so it is crucial to use POST to send data.",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 2,
		"flashcardSetId": 1,
		"name": "DDD - Value objects:",
		"text": "Measures, quantifies, or describes a thing in the domain. Identity is based on composition of values. No identity key. Immutable. - unchangeable state of objects Compared using all values No side effects - methods on value object should only compute things, they shouldn't change state of the value object. If the new value is needed, new value object is returned.",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 3,
		"flashcardSetId": 1,
		"name": "DDD: Anemic Domain Model",
		"text": "Model with classes focused on state management. Good for CRUD.",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 4,
		"flashcardSetId": 1,
		"name": "DDD:Rich Domain Model",
		"text": "Model with logic focused on behavior, not just state. Preferred for DDD.",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 5,
		"flashcardSetId": 1,
		"name": "DDD:Entity",
		"text": "A mutable class with an identity (not tied to it’s property  values) used for tracking and persistence",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 6,
		"flashcardSetId": 1,
		"name": "DDD:Immutable",
		"text": "Refers to a type whose state cannot be changed once the object has been instantiated.",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 7,
		"flashcardSetId": 1,
		"name": "DDD:Value object",
		"text": "An immutable class whose identity is dependent on the combination of its values.",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 8,
		"flashcardSetId": 1,
		"name": "DDD:Services",
		"text": "Provide a place in the model to hold behavior that doesn’t   belong elsewhere in the domain.",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 9,
		"flashcardSetId": 1,
		"name": "ACID",
		"text": "Atomic Consistent Isolated Durable",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 10,
		"flashcardSetId": 1,
		"name": "Aggregate",
		"text": "Aggregate is a cluster of associated objects that we treat as a unit for the purpose of data changes. A transactional graph of objects.",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 11,
		"flashcardSetId": 1,
		"name": "Aggregate Root",
		"text": "The entry point of an aggregate which ensures the integrity of  the entire graph",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 12,
		"flashcardSetId": 1,
		"name": "Invariant",
		"text": "A condition that should always be true for the system to be in  a consistent state.",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 13,
		"flashcardSetId": 1,
		"name": "Lazy loading",
		"text": "is a design pattern commonly used in computer programming to defer initialization of an object until the point at which it is needed. It can contribute to efficiency in the program's operation if properly and appropriately used. The opposite of lazy loading is eager loading.",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 14,
		"flashcardSetId": 1,
		"name": "YAGNI",
		"text": "You Aint Gonna Need It",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 15,
		"flashcardSetId": 1,
		"name": "Single Responsibility Separation",
		"text": "Class should have only one reason to change.  'There should never be more than one reason for a class to change.' - Robert C. 'Uncle Bob' Martin.",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 16,
		"flashcardSetId": 1,
		"name": "Open/Closed principle",
		"text": "Łatwość dodawania nowych żeczy. Nie trzeba grzebać w bebechach aby coś dodać.",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 17,
		"flashcardSetId": 1,
		"name": "Practise: 'Fool me once, shame on you. Fool me twice shame on me'",
		"text": "Don’t aply open/closed principal at first. If the module changes once. Accept it. If it changes a second time, refactor to achieve OCP.  How to achieve: Pass parameters to function Inheritance / Template method pattern - child types override behavior of base class or interface Composition/ strategy pattern - provides a plugin model",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	},
	{
		"id": 18,
		"flashcardSetId": 1,
		"name": "LSP - Liskov Substitution Principle:",
		"text": "The Liskov Substitution Principle states that Substitution Principle states that Subtypes must be substitutable for their base types. Child classes must not: Remove base class behavior Violate base class invariants Jedna klasa nie jest zastępcza dla drugiej. Square : Rectangle Rectangle r = new Square(); r.height = 4; r.width = 5; r.calculateArea() -> 25; // wywołuje metodę z klasy Square",
		"isPictureAnswer": false,
		"pictureBlob": "",
		"isLearned": false
	}
  ]
}